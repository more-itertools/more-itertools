from collections import Sequence
from typing import Any, Callable, Dict, Generic, Hashable, Iterable, Iterator, List, Mapping, Optional, Tuple, TypeVar, Union, overload, peek, seekable


T = TypeVar("T")
S = TypeVar("S")
U = TypeVar('U')
V = TypeVar('V')
H = TypeVar('H', bound=Hashable)
Predicate = Callable[[T], bool]

def chunked(iterable: Iterable[T], n: int) -> Iterator[List[T]]: ...
def first(iterable: Iterable[T], default: Any = ...): ...
def last(iterable: Any, default: Any = ...): ...

class peekable:
    def __init__(self, iterable: Any) -> None: ...
    def __iter__(self): ...
    def __bool__(self): ...
    def __nonzero__(self): ...
    def peek(self, default: Any = ...): ...
    def prepend(self, *items: Any) -> None: ...
    def __next__(self): ...
    next: Any = ...
    def __getitem__(self, index: Any): ...

def collate(*iterables: Any, **kwargs: Any): ...

collate: Any

def consumer(func: Any): ...
def ilen(iterable: Any): ...
def iterate(func: Any, start: Any) -> None: ...
def with_iter(context_manager: Any) -> None: ...
def one(iterable: Any, too_short: Optional[Any] = ..., too_long: Optional[Any] = ...): ...
def distinct_permutations(iterable: Any): ...
def intersperse(e: Any, iterable: Any, n: int = ...): ...
def unique_to_each(*iterables: Any): ...
def windowed(seq: Any, n: Any, fillvalue: Optional[Any] = ..., step: int = ...): ...
def substrings(iterable: Any) -> None: ...

Key_Res = TypeVar("Key_Res")

class bucket(Mapping[Key_Res, Iterable[T]]):
    def __init__(
        self,
        iterable: Iterable[T],
        key: Callable[[T], Key_Res],
        validator: Optional[Predicate[Key_Res]],
    ) -> None: ...
    def __contains__(self, value: Key_Res) -> bool: ...
    def __getitem__(self, value: Key_Res) -> Iterable[T]: ...

class peek(Generic[T]):
    def __init__(self, iterable: Iterable[T]): ...
    def __iter__(self) -> peek[T]: ...
    def __bool__(self) -> bool: ...
    @overload
    def peek(self) -> peek[T]: ...
    @overload
    def peek(self, default: U) -> Union[T, U]: ...
    def prepend(self, *items: T): ...
    def __next__(self) -> T: ...
    @overload
    def __getitem__(self, index: int) -> T: ...
    @overload
    def __getitem__(self, index: slice) -> List[T]: ...

def spy(
    iterable: Iterable[T], n: int = ...
) -> Tuple[Tuple[Iterable[T], ...], Iterable[T]]: ...
def interleave(*iterables: Any): ...
def interleave_longest(*iterables: Any): ...
def collapse(iterable: Any, base_type: Optional[Any] = ..., levels: Optional[Any] = ...): ...
def side_effect(func: Any, iterable: Any, chunk_size: Optional[Any] = ..., before: Optional[Any] = ..., after: Optional[Any] = ...) -> None: ...
def sliced(seq: Sequence[T], n: int) -> Iterator[Sequence[T]]: ...
# Could return Tuple[Iterator[T],Iterator[T]] with a different implementation
def split_at(iterable: Iterable[T], pred: Predicate[T]) -> Iterator[List[T]]: ...
def split_before(iterable: Iterable[T], pred: Predicate[T]) -> List[Iterator[T]]: ...
def split_after(iterable: Any, pred: Any) -> None: ...
def split_into(
    iterable: Iterable[T], sizes: Iterable[Union[int, None]]
) -> Iterable[T]: ...
def padded(iterable: Any, fillvalue: Optional[Any] = ..., n: Optional[Any] = ..., next_multiple: bool = ...) -> None: ...
def distribute(
    n: int, iterable: Iterable[T]
) -> List[Iterator[T]]: ...  # Could be a Tuple[Iterator[T], ...]
def stagger(iterable: Any, offsets: Any = ..., longest: bool = ..., fillvalue: Optional[Any] = ...): ...
def zip_offset(*iterables: Any, **kwargs: Any): ...
def sort_together(iterables: Any, key_list: Any = ..., reverse: bool = ...): ...
def unzip(iterable: Iterable[Tuple[T, S]]) -> Tuple[Iterable[T], Iterable[S]]: ...
def divide(n: Any, iterable: Any): ...
def always_iterable(obj: Any, base_type: Any = ...): ...
def adjacent(predicate: Any, iterable: Any, distance: int = ...): ...
def groupby_transform(iterable: Any, keyfunc: Optional[Any] = ..., valuefunc: Optional[Any] = ...): ...
def numeric_range(*args: Any): ...
def count_cycle(iterable: Any, n: Optional[Any] = ...): ...
def locate(iterable: Any, pred: Any = ..., window_size: Optional[Any] = ...): ...
def lstrip(iterable: Any, pred: Any): ...
def rstrip(iterable: Any, pred: Any) -> None: ...
def strip(iterable: Any, pred: Any): ...
def islice_extended(iterable: Any, *args: Any): ...
def always_reversible(iterable: Any): ...
def consecutive_groups(iterable: Any, ordering: Any = ...): ...
def difference(iterable: Any, func: Any = ...): ...

class SequenceView(Sequence):
    def __init__(self, target: Any) -> None: ...
    def __getitem__(self, index: Any): ...
    def __len__(self): ...

class seekable(Generic[T]):
    def __init__(self, iterable: Iterable[T]): ...
    def __iter__(self) -> seekable[T]: ...
    def __next__(self) -> T: ...
    def elements(
        self
    ) -> SequenceView[T]: ...  # TODO: annotate the generic SequenceView
    def seek(self, index: int) -> Iterable[T]: ...

class run_length:
    @staticmethod
    def encode(iterable: Any): ...
    @staticmethod
    def decode(iterable: Any): ...

def exactly_n(iterable: Any, n: Any, predicate: Any = ...): ...
def circular_shifts(iterable: Any): ...
def make_decorator(wrapping_func: Any, result_index: int = ...): ...

@overload
def map_reduce(iterable: Iterable[T], keyfunc: Callable[[T], H]) -> Dict[H, List[T]]: ...
@overload
def map_reduce(iterable: Iterable[T], keyfunc: Callable[[T], H], valuefunc: Callable[[T], U]) -> Dict[H, List[U]]: ...
@overload
def map_reduce(iterable: Iterable[T], keyfunc: Callable[[T], H], *, reducefunc: Callable[[List[T]], U]) -> Dict[H, List[U]]: ...
@overload
def map_reduce(iterable: Iterable[T], keyfunc: Callable[[T], H], valuefunc: Callable[[T], U], reducefunc: Callable[[List[U]], V]) -> Dict[H, V]: ...

def rlocate(iterable: Any, pred: Any = ..., window_size: Optional[Any] = ...): ...
def replace(iterable: Any, pred: Any, substitutes: Any, count: Optional[Any] = ..., window_size: int = ...) -> None: ...
